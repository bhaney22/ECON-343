---
title: "Empirical Project Exploratory Analysis lastname, firstname"
output:
  html_document:
    number_sections: yes
    toc: yes
    toc_collapsed: yes
    toc_float: yes
    toc_levels: 4
---

```{r setup, include=FALSE}
#
# Always include these packages in R projects for this class
#
library(readr)      # for reading in .csv files
library(tidyverse)  # data wrangling
library(dplyr)      # for filter and select commands. etc.

library(wooldridge) # datasets in the textbook
library(stats)      # basic statistic commands
library(DataExplorer) # nice commands to learn about a new data set
library(stargazer)  # nice regression output
library(ggformula)  # easy graphing interface for ggplot
library(mosaic)     # accompanies ggformula
library(haven)      # reading in .dta and .sav data (other stats packages)
library(expss)      # apply_labels() cro()

library(AER)        # data and commands specific to econometrics
library(car)        # for linearhypothesis tests lht(), predict() hccm() heterosced.
library(lmtest)     # post-reg tests coeftest()
library(effects)    # to plot effects of one regressor, holding all others constant
library(visualize)  # to visualize hypothesis test p-values

library(dynlm)      # lm commands for time series data
library(plm)        # lm commands for panel data


options(digits=4)   # limits number of decimals to 4 when printing

knitr::opts_chunk$set(echo = TRUE) # TRUE = commands in r chunks to be echoed in outfile
```

# Get ready! 

Before you get started, you need to read in the data, and get the data cleaned and organized. You will handle missing values and create new
variables and categories based on what you need. Sometimes you will
combine data from different datasets together. All of this is 
known as "data wrangling".

## Read in the dataset

INSTRUCTIONS:

1. First, download the 2018 GSS dataset in SPSS format from the GSS website:
https://gss.norc.org/get-the-data/spss
2. It will download as a .zip file
3. Upload the .zip file to Rstudio - R will automatically unzip it
4. Make sure you change the location of the dataset to where you saved it
5. You can add more variables from the GSS by adding them to the "select" statement

```{r}
mygss <- as.data.frame(read_sav("GSS/GSS2018.sav")) %>%
  select(YEAR,ID,WRKSTAT,SEX,RACE,RINCOME,INCOME,WEALTH,REGION,
         AGE,MARITAL,CHILDS,EDUC,DEGREE,
         PARTYID,PRES16,NATEDUC,COURTS,TAX,NATFARE,
         PARTTEAM) 

stargazer(mygss,type="text", 
          digits = 0, 
          summary.stat = c("n","min","max","median","mean","sd"))

as_tibble(mygss)
```


## Recode missings

The first data wrangling task is almost always to recode missings.

- You can examine the value labels of the variables to identify actual values that
should be recoded as missing. For example, '9' is a common value that denotes "Refused to answer." You want it to be recoded to "NA" (R's term for a missing value)

- You can also refer to the codebook on the GSS website to obtain even more
detailed information and the actual survey questions for the variables:
https://gss.norc.org/Get-Documentation

- Look for values that will need to be recoded as missing (e.g. IAP, DK)
- Look for variables you will want to collapse to few categories

- Usually, survey data have some values that are actually missing. For example, 
for some variables a '9' indicates Don't Know and sometimes '0' indicates IAP (inapplicable).

- Before running analysis, these values must be converted to missings so they don't get treated as actual values.

### Step 1: Use `val_lab()`

- Use `val_lab()` to display the value labels 
- Identify values that should be changed to missing, such as 9 = "Refused")
- Alternatively, you can look in the GSS Codebook to determine the numerical values 
for each variable that you need to recode
- Value labels for most of the variables are in the following r chunk

``` {r include =FALSE}
val_lab(mygss$WRKSTAT)
val_lab(mygss$SEX)
val_lab(mygss$RACE)
val_lab(mygss$RINCOME)
val_lab(mygss$INCOME)
val_lab(mygss$WEALTH)
val_lab(mygss$REGION)

val_lab(mygss$AGE)
val_lab(mygss$MARITAL)
val_lab(mygss$CHILDS)
val_lab(mygss$EDUC)
val_lab(mygss$DEGREE)

val_lab(mygss$PARTYID)
val_lab(mygss$PRES16)

val_lab(mygss$NATEDUC)
val_lab(mygss$COURTS)
val_lab(mygss$NATFARE)
val_lab(mygss$TAX)

val_lab(mygss$PARTTEAM)

```

### Step 2. Use `mis_val()`

Use the `mis_val()` command to recode categories that represent missing values into actual missing values ("NA"). The `with_labels = TRUE` option drops the labels so those categories don't show up in the tables

Usage:

**mis_val**(*varname*,c(*list of numerical values*))

UPDATE: 7.11.2020 - Remove the "with_labels = TRUE" option. That can cause errors later. 

```{r}

# Demographic variables...
mygss$RINCOME <- mis_val(mygss$RINCOME,c(0,13,98,99))
mygss$INCOME  <- mis_val(mygss$INCOME,c(0,13,98,99))
mygss$WEALTH  <- mis_val(mygss$WEALTH,c(0,98,99))
mygss$AGE     <- mis_val(mygss$AGE,c(98,99))
mygss$EDUC    <- mis_val(mygss$EDUC,c(97,98,99))
mygss$RACE    <- mis_val(mygss$RACE, 0)
mygss$DEGREE  <- mis_val(mygss$DEGREE, c(7,8,9))
mygss$MARITAL <- mis_val(mygss$MARITAL, c(9))
mygss$CHILDS  <- mis_val(mygss$CHILDS, c(9))
mygss$WRKSTAT <- mis_val(mygss$WRKSTAT, c(0,9))
mygss$REGION  <- mis_val(mygss$REGION, 0)
mygss$PARTYID <- mis_val(mygss$PARTYID, c(8,9)) 
mygss$PRES16  <- mis_val(mygss$PRES16, c(0,3,4,8,9))
mygss$COURTS  <- mis_val(mygss$COURTS, c(0,8,9))
mygss$NATEDUC <- mis_val(mygss$NATEDUC, c(0,8,9))
mygss$NATFARE <- mis_val(mygss$NATFARE, c(0,8,9))
mygss$TAX     <- mis_val(mygss$TAX, c(0,8,9,4))
mygss$PARTTEAM   <- mis_val(mygss$PARTTEAM, c(0,8,9))

```


## Create new variables 

- You will often want to create new variables so that you can
reduce the number of categories of a variable. 
- Be sure to
document what the categories mean so that you can
label them correctly.
- Use `mutate()` with `case_when()` to collapse several categories into a few

Usage:

datasetname <- datasetname %>%
     mutate(**newvarname** = 
     case_when(condition 1 ~ value if condition 1 holds, 
     condition * ~ value if condition 2 holds))


The following code chunk creates new variables *party*, *region*, *labor force status*, and *agegrp* by collapsing the values of PARTYID, REGION, WRKSTAT, and AGE into a smaller number of categories, using the category cutoffs in the GSS Trend Graphs.

UPDATE: 7.11.2020 - use labels for the recoded values, rather than numbers
UPDATE: 7.11.2020 - use 0/1 (not characters) when creating dummy variables

``` {r}

# The GSS variable PARTYID was recoded 
# into four categories: (0)-(1) Democrat; (2)-(4),(7) Independent, Other; and (5)-(6) 
# Republican. 

# The GSS variable REGION was recoded into four categories: (1)-(2) Northeast; 
# (3)-(4) Midwest; 
# (5)-(7) South; (8)-(9) West. These are in alignment with the Census regional groupings.

# The GSS variable WRKSTAT was recoded into three categories: 
# (1)-(3) Employed, (4) Unemployed, 
# and (5)-(8) Not in labor force/Other. 
# This is in alignment with the Bureau of Labor Statistic's labor force definitions.

mygss <- mygss %>%
  mutate(party = case_when(PARTYID == 5 | PARTYID == 6 ~ "Republican",      
                           PARTYID == 0 | PARTYID == 1 ~ "Democrat",      
                           PARTYID >= 2 & PARTYID <= 4 ~ "Independent",      
                           PARTYID == 7 ~ "Independent"),
         
         region = case_when(REGION == 1 | REGION == 2 ~ "NE",     
                              REGION == 3 | REGION == 4 ~ "Midwest",    
                              REGION == 5 | REGION == 6 | REGION == 7 ~ "South", 
                              REGION == 8 | REGION == 9 ~ "West"),    
         
         # LFS = Labor Force Status
         lfs    = case_when(WRKSTAT <= 3 ~ "Employed",                    
                            WRKSTAT == 4 ~ "Unemployed",                    
                            WRKSTAT > 4 & WRKSTAT < 9 ~ "OLF"),      

         agegrp = case_when(AGE >= 18 & AGE <= 34 ~ "Age 18-34",
                            AGE >= 35 & AGE <= 49 ~ "Age 35-49" ,
                            AGE >= 50 & AGE <= 64 ~ "Age 50-64",
                            AGE >= 65 ~ "Age 65+")
  )

# Check accuracy of recodes
cro(mygss$PARTYID,mygss$party)
cro(mygss$REGION,mygss$region)
cro(mygss$WRKSTAT,mygss$lfs)
```

**Dummy variables**

Dummy variables are "0/1" variables, with value = 1 if the variable is true
and value = 0 if the variable is false

- give dummy variables values of 0/1 rather than categorical names.

``` {r}

                              
mygss <- mygss %>%         
         mutate(teamwork = case_when(PARTTEAM == 1 ~ 1,
                              PARTTEAM == 2 ~ 0),
          married  = case_when(MARITAL == 1 ~ 1,
                              MARITAL  > 1 ~ 0),
          haschild = case_when(CHILDS   > 0 ~ 1, 
                               CHILDS == 0 ~ 0)
  )

cro(mygss$PARTTEAM,mygss$teamwork)
cro(mygss$MARITAL,mygss$married)
cro(mygss$CHILDS,mygss$haschild)
```


## Label variables
Variable labels are important for making tables and results "human readable". 

Use `apply_labels()` to:

- Name or rename variables

Usage:

- datasetname <- **apply_labels**(datasetname,*var1* = "var label 1")


UPDATE: 7.11.2020 - do not use apply_labels() for value labels. See note above - 
use the value labels instead of a number in the `mutate(case_when())` recode command.

UPDATE: 7.11.2020 - the as_factor() command is no longer needed and is removed 


``` {r}
mygss <-  apply_labels(mygss,
    party  = "Political Party",
    region = "Region",
    lfs    = "Labor Force Status",
    agegrp     = "Age",
    married    = "Married",
    haschild   = "Has Children",
    teamwork   = "Works in team"
  )
```



# Get set!

Take stock of the variables you have to work with. 

Use the following `cro()` commands to look at the frequencies of the variables.

- `cro()` with one variable displays the for each level of a factor variable
- `cro_cpct()` reports percentage responses for each level of a factor variable
- `cro_cpct(var1,var2)` with two variables. The second variable is the explanatory variable
- use `cro_cpct()` with `%nest%` for more than one explanatory variable (see below)

UPDATE: 7.11.2020 

- use `drop_rc()` in front of all `cro()` and related table commands to prevent the display of empty rows or columns

## Dependent Variables

``` {r}

drop_rc(cro_cpct(mygss$COURTS))
drop_rc(cro_cpct(mygss$NATEDUC))
drop_rc(cro_cpct(mygss$NATFARE))
drop_rc(cro_cpct(mygss$TAX))
drop_rc(cro_cpct(mygss$teamwork))

```


## Demographic Variables
``` {r}
drop_rc(cro(mygss$SEX))
drop_rc(cro_cpct(mygss$RACE))
drop_rc(cro_cpct(mygss$agegrp))
drop_rc(cro_cpct(mygss$region))
drop_rc(cro_cpct(mygss$married))
drop_rc(cro_cpct(mygss$haschild))

```

##  Explanatory Variables
``` {r}

stargazer(mygss,type="text", 
          digits = 0, 
          summary.stat = c("n","min","max","median","mean","sd"))

drop_rc(cro_cpct(mygss$DEGREE))
drop_rc(cro_cpct(mygss$lfs))
drop_rc(cro_cpct(mygss$RINCOME))
drop_rc(cro_cpct(mygss$INCOME))
drop_rc(cro_cpct(mygss$WEALTH))
drop_rc(cro_cpct(mygss$party))
drop_rc(cro_cpct(mygss$PRES16))

```

## Graphs

```{r}
gf_bar(~ party, data = mygss)
```


# Go! 

Explore the variables to:

- Look for statistically signficiant differences across groups
- Look for particularly important control variables

## Add statistical significance to R tables:

- use `cro_cpct()` with two variables
- add the pipe command `%>%`
- add the `significance_cpct()` option 
to display statistical signficance between columns

How to read the table:

- the table columns are labeled with letters. 
- the letters next to a value in the table indicates that the value of the variable for this group is statistically significantly larger than the value for the group in a different column.

## Voting example
``` {r}

drop_rc(cro_cpct(mygss$party,mygss$PRES16)) %>% 
  significance_cpct()

```

This table was a helpful "reality check" for me. When I ran this the very first
time, I noticed quite a few democrats voted for Trump, Hm. I went back and checked my re-codes. Sure enough, I had mis-coded one value.

## COURTS example

Suppose you want to see if
beliefs about *COURTS* appear to be related to the *region* of the
respondent
``` {r}
drop_rc(cro_cpct(mygss$COURTS,mygss$region)) %>% 
  significance_cpct()

```

It appears that the percent of respondents in the Midwest that believe courts are 
"about right" is statistically significantly lower than all other regions. The
percent in the 
Midwest that believe courts are "not harsh enough" is higher than all other regions,
but that difference is not statistically significant.


## %nest% command

Are the differences statistically significant after controlling for race?

Use the %nest% command to compare categories within another category

Usage:

- cro(*row variable*, *top level* %nest% *bottom level* )

``` {r}
drop_rc(cro_cpct(mygss$COURTS, mygss$RACE %nest%  mygss$region)) %>%   
  significance_cpct()

```

After controlling for race, it appears that the percentage of whites in the Midwest
how believe courts are "not harsh enough" is statistically significantly 
greater than the percent of whites in other regions. What do you notice in these
results?



# Your turn

What relationships do you want to explore? Choose one that you find interesting
and share it on the Community Learning forum this week. You can take a screen shot
of the table, or print the html page as a .pdf and upload it to the post.

You might want to recode some of the variables differently. Or, you might even want
to explore the GSS for additional variables. You can add new variables from the
GSS by adding their name to the "select()" statement when reading in the dataset.

``` {r}



```


# Save the final version of your mygss file so you can use it in your report.

UPDATE: 7.11.2020 - Save the file you created during the exploratory
analysis and then read it in at the start of your final empirical project report.

```{r}
save(mygss,file="mygss.RData")

```

